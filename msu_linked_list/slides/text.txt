Всем добрый день. Меня зовут Александр, я студент факультета Вычислительной Математики и Кибернетики МГУ. Я изучаю микроархитектуру и проектирование микросхем под руководством Михаила Сергеевича Шуплецова, доцента кафедры математической кибернетики и к.ф.-м.н..

(слайд со связанным списком)
Все мы отлично знем, что такое связанный список. Он схематично изображен на верхнем рисунке. Связанный список – структура данных, используемая для хранения динамической информации. Ячейка связанного списка состоит из двух основных компонент – собственно информации, хранимой в ячейке, и указателя на следующую ячейку. В software связанные списки используются повсеместно. В software связанный список может расти за счет памяти, выделяемой операционной системой для каждой новой ячейки, и уменьшаться за счет освобождения этой памяти.

Во многих специализированных устройствах память ограничена, и должна распределяться эффективно. В частности, памяти может быть недостаточно для работы операционной системы, которая могла бы распределять память программным образом. Что делать в таком случае? В таком случае появляется необходимость в аппаратной реализации алгоритмов распределения памяти. В силу простоты и эффективности, в качестве структуры данных повсеместно используются именно связанные списки. Я расскажу о том, как спроектировать аппаратный блок работы с ними. Далее для простоты аппаратный блок для работы со связанным списком я буду называть просто связанным списком.

******************Примеры использования (опционально/ для ответов на вопросы)***************
Потребность в связанных списках при обработке цифровых изображений. Они применяются в аппаратных реализациях алгоритмов компьютерного зрения, например, при поиске компонент связности [3]. Кроме того, при потоковой обработке изображений необходимо работать с непрерывным потоком динамических изменяющихся данных. Связанные списки отлично подходят для решения задач такого рода и используются, в частности, в так называемых системах подсчета посетителей [4].

Связанные списки используются при обработке сообщений в суперкомпьютерах с распределенной памятью. Решение, основанное на связанных списках, в разы эффективнее других известных аппаратных решений, легко маштабируется и хорошо подходят для работы с динамическими данными [2].

********************************************************************************************


Для наглядности и универсальности связанный список будет работать с последовательностью указателей, т. е. связанным списком без данных. На нижнем рисунке изображен такой связанный список с обозначениями, которыми мы будем пользоваться. Ноль означает конец последовательности.

Наш аппаратный блок будет представлять собой генератор указателей: он будет принимать на вход указатель на начало последовательности, и выдавать последовательность целиком по одному указателю за такт. Будем проектировать от простого к сложному. Простейшая версия будет хранить указатели в константном массиве. Шаг за шагом будем усложнять способ хранения указателей и изменять связанный список соответствующим образом, постепенно приближая его к тому, с чем можно встретиться в реальной жизни. 

(слайд с планом)
План проектирования:
1. Указатели хранятся в массиве констант
2. Указатели хранятся в регистровом файле
3. Выносим регистровый файл в отдельный модуль
4. Заменяем регистровый файл на SRAM с латентностью Lat
5. Скрываем латентность (изюминка моего доклада)

1. Указатели хранятся в массиве констант

(На слайдах будет показан поток данных внутри рассматриваемого модуля по одному слайду на такт.)
Сигнал start_rdy означает, что блок готов к началу работы. (слайд) После того, как на вход start подается валидный указатель на начало списка,  он сохраняется в регистр cur.(слайд) На следующем такте он подается на выход out_ptr, а в регистр cur помещается следующий указатель. (слайд) Это повторяется до конца списка, то есть до тех пор, пока в регистр cur не будет помещен 0. (слайд) Когда это произойдет, будет поднят сигнал start_rdy в знак того, что модуль готов получить указатель на начало следующего списка. (слайд) Когда на вход start поступит новый валидный указатель, наш связанный список начнет выдавать на выход out_ptr новую последовательность. (слайд) И так до конца очередного списка, то есть пока в cur не будет помещен 0. (слайд) После этого возвращаемся в исходное состояние. (слайд)


Я подготовил демонстрацию работы только что описанного модуля на физической плате.
(демо step1.mp4)
Крайний левый светодиод - это тактовый генератор, т. е. сигнал clock. Крайний правый светодиод - это сигнал out_ptr_vld. На крайний правый семисегментный индикатор выводится значение очередного указателя.

Заметим, что список спроектирован таким образом, что между выдачей последовательностей есть пауза в один такт (т.н. gap). Усовершенствуем нашу реализацию, убрав эту паузу. 

1*. Указатели хранятся в массиве констант (no gaps)

В начале происходит все то же самое. Но теперь мы не дожидаемся, пока в регистр cur будет помещен 0. Вместо этого каждый раз, когда в cur помещается очередное значение, мы сразу проверяем, не указывает ли оно на ячейку помяти, содержащую 0, и если указывает, то поднимаем сигнал start_rdy. Таким образом этих gap-ов можно избежать. Стоит заметить, что это приведет к усложнению логики, что может сказаться на скорости работы.

2. Указатели хранятся в регистровом файле

Перейдем к следующей реализации. Теперь указатели будут храниться не в константном массиве, а в регистровом файле, то есть в который можно писать. Теперь перед началом работы нашего генератора указателей ее надо инициализировать. Опишем процесс инициализации. 

Для инициализации памяти в наешем модуле появляются новые входы. Перед тем, как связанный список будет готов к работе, последовательности указателей заносятся в регистровый файл самым простым и очевидным образом. На вход init_ptr подается адрес, на вход init_ptr_next подается значение, т. е. следующий указатель. И так до тех пор, пока память не будет инициализирована.

(слайды с анимацией)
 
Процесс генерации указателей ничем не отличается от предыдущего этапа, поэтому не буду тратить время на слайды, которые уже были показаны и перейду сразу к демонтсрации.

(демо step2)

Теперь для того, чтобы начать генерировать указатели, блоку нужно время для инициализации. 

3. Выносим регистровый файл в отдельный модуль

Ничего идейно нового в этой реализации нет. Поднимается сигнал start_rdy, на вход start подается указатель на начало списка, который сохраняется в регистре cur. На следующем такте указатель выводится на выход out_ptr, который в свою очередь подключен к входу read address модуля regfile. regfile выдает на выход read data значение следующего указателя, которое сохраняется в регистре cur. И так далее.
Заголовок говорит сам за себя


4. Заменяем регистровый файл на SRAM с латентностью Lat

Теперь связанный список будет работать в условиях, максимально приближенных к реальным. Без значительных изменений в логике его работы, он будет вынужден работать со скоростью памяти, т. е. медленно. Для того, чтобы синхронизировать связанный список с памятью, введем регистр lat_counter. ... Модуль memory выдаст следующий указатель на выход read data не сразу, а только через Lat тактов, т. е. когда значение в регистре lat_counter снова станет 0.

На демонстрации видно, что список теперь выдает очередной указатель не каждый такт, а в Lat раз реже. В остальном все также, как на предыдущем этапе.

5. Скрываем латентность

Теперь самое интересное. До сих пор мы пользовались линейной памятью для хранения указателей. (на слайде сверху) Чтобы скрыть латентность, будем использовать память ширины Lat + 1. Указатели в этой памяти будут объединены в т. н. записи. Последний указатель записи указывает на следующую запись. Такая память будет получать на вход указатель (на начало списка), и через Lat тактов выдавать запись, состоящую из Lat+1 последовательных указателей. Еще через Lat тактов - еще запись и т. д.

Как всегда, поднимается сигнал start_rdy. На вход start подается указатель на начало последовательности. Он сохраняется в регистре cur_addr. На следующем такте - в регистре ra, который подключен ко входу ra модуля memory. Напоминаю, что memory выдаст следующий указатель на выход rd только через Lat тактов. Тем временем, внимательные уже обратили внимание на регистр pop_ptr. В этом дезайне он используется в частноти для того, чтобы синхронизироваться с памятью. Кроме того, он понадобится в дальнейшем, для того, чтобы по одному выдавать указатели из записи, которая будет извлечена из memory.

В момент, когда pop_ptr = Lat, значение из start сохраняется в регистр cur_out, с тем, чтобы на следующем такте (когда pop_ptr будет равно 0), выдать его на out_ptr.

Вообще, на следующем такте происходит много всего. memory выдает значение следующего указателя на rd. Напомню, из memory читывается не один указатель, а целая запись из Lat + 1 указателя (в нашем случае из 3). Если запись содержит 0, на котором заканчивается очередной список, то нам не интересно, что там лежит после нуля. Пропускаем запись через модуль filter,  который отфильтровывает ячейки записи после первого нуля. Дальше на примере будет показано, как он работает. Отфильтрованная запись сохраняется в buffer. Напоминаю, что pop_ptr указывает на очередной указатель в buffer, начиная с самого первого. Указатель, на который указывает pop_ptr, сохраняется в регистре cur_out. В регистр cur_addr тем временем сохраняется последний указатель из записи в буфере, чтобы на следующем такте передать его на вход ra модуля memory. Вот так много всего происходит за один такт. За скрытие латентности приходится платить не только увеличением необходимой памяти в Lat+1 раз, но и значительным усложнением логики.

Дальше указатель на начало следующей записи передается из регистра cur_addr в регистр ra, подключенного ко входу ra модуля memory. В на выход out_ptr передается значение из cur_out, а в cur_out помещается очередной указатель из буфера, на котрый указывает pop_ptr.

На следующем такте то же самое.

Снова такт, на котором много логики. Как я и обещал, на примере можно увидеть, как работает модуль filter. Он отфильтровывает все после первого нуля, и в буффер помещается отфильтрованная запись. Поскольку последний указатель буфера равен нулю, он не сохраняется в регистре cur_out. Вместо этого, в cur_out считывается указатель на следующий список и поднимается сигнал start_rdy.


Указатель из регистра cur_addr передается в регистр ra.

Ждем Lat тактов.

Получаем следующую запись

Возвращаемся в исходное состояние.

(демонстрация)

На демонстрации видно, что между последовательностями есть gapы, вызванные тем, что модуль работает синхронно с памятью. Их наверняка можно как-то соптимизировать.

Таким образом, было рассмотрены варианты реализации аппаратного блока работы с динамическими структурами данных, а именно со связанными списками. В качестве бонуса было показано, как можно скрыть латентность памяти при работе со связанными списками. Модули, которые мы обсуждали, описаны на языке System Verilog и выложены в открытом доступе в моем репозитории. Ссылку сейчас скину в чат. Демо на плате синтезировано с помощью Quartus Prime Lite.

https://github.com/demialexa/2021dev/blob/msu_linked_list/msu_linked_list/

Спасибо за внимание. Если у кого-нибудь есть вопросы, самое время их задать.


